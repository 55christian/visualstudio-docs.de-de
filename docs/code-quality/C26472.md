---
title: C26472
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26472
helpviewer_keywords:
- C26472
ms.assetid: 51e215a7-0e0a-4e6c-bff1-805bf5b1af29
author: mikeblome
ms.author: mblome
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 88eaf06d33946531a01f9a4a1fe3e48db90ff32c
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/23/2019
ms.locfileid: "62560596"
---
# <a name="c26472-nocastsforarithmeticconversion"></a>C26472 NO_CASTS_FOR_ARITHMETIC_CONVERSION

"Verwenden Sie nicht" static_cast"für arithmetische Konvertierungen. Initialisierung mit geschweiften Klammern verwenden, gsl::narrow_cast oder gsl::narrow."

**C++ Core Guidelines**: Type.1: Vermeiden Sie Umwandlungen

Mit dieser Regel können stellen finden, in denen statische Umwandlungen verwendet werden, für die Konvertierung zwischen ganzzahligen Typen, die ist unsicher, da der Compiler würde nicht warnen, wenn kein Datenverlust auftritt. Initialisierer für geschweifte Klammer sind besser für die Fälle, in denen Konstanten werden verwendet, und es wird ein Compilerfehler erwünscht ist. Es gibt auch Dienstprogramme Guidelines-Unterstützungsbibliothek, mit denen Sie die Absichten klar beschreiben:
- GSL::Narrow stellt die Verlustlose Konvertierung sicher und Absturz zur Laufzeit wird, wenn es nicht möglich ist.
- GSL::narrow_cast gibt klar an, dass die Konvertierung kann Daten verloren gehen, und es ist akzeptabel.

## <a name="remarks"></a>Hinweise

- Mit dieser Regel wird nur für Static_casts implementiert. Mithilfe von C-stilartige Umwandlungen ist jedoch nicht empfohlen.

## <a name="example"></a>Beispiel

nicht behandelte unerwartete Daten

```cpp
rgb from_24bit(std::uint32_t v) noexcept {
    return {
        static_cast<std::uint8_t>(v >> 16),         // C26472, what if top byte is non-zero?
        static_cast<std::uint8_t>((v >> 8) & 0xFF), // C26472
        static_cast<std::uint8_t>(v & 0xFF)         // C26472
    };
}
```

nicht behandelte unerwartete Daten – sicherer version

```cpp
rgb from_24bit(std::uint32_t v) noexcept {
    return {
        gsl::narrow<std::uint8_t>(v >> 16),
        gsl::narrow_cast<std::uint8_t>((v >> 8) & 0xFF),
        gsl::narrow_cast<std::uint8_t>(v & 0xFF)
    };
}
```
