---
title: C26414
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26414
helpviewer_keywords:
- C26414
ms.assetid: dd875d0c-6752-4491-a533-3e8831795fbc
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 8ced283edb792ee917706974070dce407cc29f5a
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/07/2019
ms.locfileid: "72011676"
---
# <a name="c26414-reset_local_smart_ptr"></a>C26414 RESET_LOCAL_SMART_PTR

"Verschieben, kopieren, Neuzuweisen oder Zurücksetzen eines lokalen intelligenten Zeigers".

Grundlegende Richtlinien: **C++** R. 5: Bereichs bezogene Objekte bevorzugen, nicht unnötig Heap zuordnen

Intelligente Zeiger sind praktisch für die dynamische Ressourcenverwaltung, aber Sie sind nicht immer erforderlich. Beispielsweise kann das Erstellen eines lokalen dynamischen Puffers problemlos (manchmal effizienter) durch Standardcontainer verwaltet werden. Bei einzelnen Objekten ist es möglicherweise unnötig, eine dynamische Zuordnung durchzuführen (z. b. wenn solche Objekte ihre erstellerfunktion niemals überdauern) und durch lokale Variablen ersetzt werden können. Intelligente Zeiger werden nützlich, wenn das Szenario eine Änderung des Besitzes erfordert, d. h. eine erneute Neuzuweisung einer dynamischen Ressource oder mehrerer Pfade. Dies umfasst auch Fälle, in denen Ressourcen aus externem Code abgerufen werden und intelligente Zeiger verwendet werden, um die Lebensdauer von Ressourcen zu erweitern.

## <a name="remarks"></a>Hinweise

- Zusätzlich zu den Standardvorlagen für Std:: unique_pointer und Std:: shared_pointer werden mit dieser Prüfung benutzerdefinierte Typen erkannt, die wahrscheinlich als intelligente Zeiger gedacht sind. Es wird erwartet, dass solche Typen die folgenden Vorgänge definieren:
  - überladene Dereferenzierungsoperatoren oder Element Zugriffs Operatoren, die öffentlich und nicht als gelöscht markiert sind.
  - öffentlicher Dekonstruktor, der weder gelöscht noch standardmäßig ausfällt. Dies schließt dektoren ein, die explizit als leer definiert sind.
  - Der Typ Microsoft:: WRL:: comptr verhält sich als frei gegebener Zeiger, wird aber häufig in sehr spezifischen Szenarien verwendet, die von der Verwaltung der com-Lebensdauer betroffen sind. Um übermäßig hohe Rauschen zu vermeiden, wird dieser Typ herausgefiltert.
  - Diese Prüfung sucht nach expliziten lokalen Zuordnungen, die intelligenten Zeigern zugewiesen werden, um zu ermitteln, ob Bereichs bezogene Variablen als Alternative angegeben werden könnten. Zusätzlich zu direkten Aufrufen von New-Operator werden spezielle Funktionen wie Std:: make_unique und Std:: make_shared auch als direkte Zuordnungen interpretiert.

## <a name="example"></a>Beispiel

dynamischer Puffer

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::make_unique<char[]>(f.size()); // C26414
    f.unpack(buffer.get());
    // ...
}
```

dynamischer Puffer – durch Container ersetzt

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::vector<char>(f.size());
    f.unpack(buffer.data());
    // ...
}
```
