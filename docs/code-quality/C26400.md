---
title: C26400
ms.date: 08/02/2017
ms.topic: conceptual
f1_keywords:
- C26400
helpviewer_keywords:
- C26400
ms.assetid: b27e1c6d-8b52-40b3-9760-b93afef19c7a
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: ea1e4a708765a173231689cd9c2037a4a20158af
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/07/2019
ms.locfileid: "72016616"
---
# <a name="c26400-no_raw_pointer_assignment"></a>C26400 NO_RAW_POINTER_ASSIGNMENT

Diese Überprüfung hilft beim Erzwingen der *rule I. 11: Übertragen Sie den Besitz niemals über einen rohzeiger (T @ no__t-0)* , bei dem es sich um eine Teilmenge der Regel handelt *R. 3: Ein rohzeiger (T @ no__t-0) ist nicht Besitz.* Insbesondere wird bei jedem Operator `new` gewarnt, der das Ergebnis in einer Variablen vom Typ "unformatierten Zeiger" speichert. Sie warnt auch bei Aufrufen von Funktionen, die `gsl::owner<T>` zurückgeben, wenn Ihre Ergebnisse unformatierten Zeigern zugewiesen werden. Die Idee besteht darin, dass Sie den Besitz der Speicherressourcen eindeutig angeben sollten. Weitere Informationen finden Sie in den [ C++ grundlegenden Richtlinien](http://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

Die einfachste Möglichkeit, dieses Problem zu beheben, ist die Verwendung von `auto`-Deklaration, wenn die Ressource sofort der Variablen Deklaration zugewiesen wird. Wenn dies nicht möglich ist, empfehlen wir, dass Sie den Typ `gsl::owner<T>` verwenden. Die `auto`-Deklarationen, die mit dem Operator `new` initialisiert werden, sind "Owners", da wir davon ausgehen, dass das Ergebnis einer Zuordnung implizit ein Besitzer Zeiger ist. Wir übertragen diese Annahme an die Variable `auto` und behandeln Sie als `owner<T>`.

Wenn diese Überprüfung einen aufrufsvorgang für eine Funktion Kenn Kennzeichen, die `owner<T>` zurückgibt, ist dies möglicherweise ein Hinweis auf einen legitimen Fehler im Code. Im Grunde verweist er auf eine Stelle, an der der Code ein explizites Konzept des Besitzes (und vielleicht auch die Ressource selbst) abgibt.

## <a name="remarks"></a>Hinweise

Diese Regel überprüft zurzeit nur lokale Variablen. Wenn die Zuordnung einem formalen Parameter, einer globalen Variable, einem Klassenmember usw. zugewiesen ist, wird Sie nicht gekennzeichnet. Die entsprechende Abdeckung dieser Szenarios ist Teil der zukünftigen Arbeit.

## <a name="example-1-simple-allocation"></a>Beispiel 1: Einfache Zuordnung

```cpp
char *buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // C26400
```

## <a name="example-2-simple-allocation-fixed-with-gslownert"></a>Beispiel 2: Einfache Zuordnung (mit "gsl:: Owner @ no__t-0t >" korrigiert)

```cpp
gsl::owner<char*> buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // OK

Example 3: Simple allocation (fixed with auto)
auto buffer = useCache ? GetCache() : new char[bufferSize]; // OK
```
