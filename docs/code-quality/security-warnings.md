---
title: Sicherheitswarnungen
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 004f10600df3ed2f9c1f62557e0915638482877e
ms.sourcegitcommit: d233ca00ad45e50cf62cca0d0b95dc69f0a87ad6
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/01/2020
ms.locfileid: "75587211"
---
# <a name="security-warnings"></a>Sicherheitswarnungen

Sicherheitswarnungen sorgen für sicherere Bibliotheken und Anwendungen. Diese Warnungen tragen dazu bei, Sicherheitsmängel im Programm zu vermeiden. Wenn Sie eine dieser Warnungen deaktivieren, sollten Sie den Grund dafür im Code deutlich angeben und außerdem den für Ihr Entwicklungsprojekt zuständigen Sicherheitsbeauftragten informieren.

## <a name="in-this-section"></a>In diesem Abschnitt

|Regel|Beschreibung|
|----------|-----------------|
|[CA2100: SQL-Abfragen auf Sicherheitsrisiken überprüfen](../code-quality/ca2100.md)|Eine Methode legt die System.Data.IDbCommand.CommandText-Eigenschaft mithilfe einer Zeichenfolge fest, die aus einem Zeichenfolgenargument für die Methode erstellt wird. Diese Regel setzt voraus, dass das Zeichenfolgenargument Benutzereingaben enthält. Eine aus Benutzereingaben erstellte SQL-Befehlszeichenfolge ist anfällig für SQL-Injection-Angriffe.|
|[CA2102: Nicht-CLSCompliant-Ausnahmen in allgemeinen Handlern abfangen](../code-quality/ca2102.md)|Ein Member in einer Assembly, die nicht mit dem RuntimeCompatibilityAttribute bzw. mit RuntimeCompatibility(WrapNonExceptionThrows = false) gekennzeichnet ist, enthält einen Catch-Block zur Behandlung von System.Exception und keinen unmittelbar folgenden allgemeinen Catch-Block.|
|[CA2103: Imperative Sicherheit überprüfen](../code-quality/ca2103.md)|Eine Methode verwendet imperative Sicherheit und erstellt möglicherweise die Berechtigung mit Zustandsinformationen oder Rückgabewerten, die sich ändern können, während die Forderung wirksam ist. Verwenden Sie, wenn irgend möglich, deklarative Sicherheit.|
|[CA2104: Schreibgeschützte änderbare Referenztypen nicht deklarieren](../code-quality/ca2104.md)|Ein extern sichtbarer Typ enthält ein extern sichtbares schreibgeschütztes Feld, bei dem es sich um einen änderbaren Referenztyp handelt. Ein änderbarer Typ ist ein Typ, dessen Instanzdaten geändert werden können.|
|[CA2105: Arrayfelder dürfen nicht schreibgeschützt sein](../code-quality/ca2105.md)|Wenn Sie den schreibgeschützten Modifizierer (ReadOnly in Visual Basic) auf ein Feld mit einem Array anwenden, kann das Feld nicht geändert werden, um auf ein anderes Array zu verweisen. Allerdings können die in einem schreibgeschützten Feld des Arrays gespeicherten Elemente geändert werden.|
|[CA2106: Sichere Assert-Vorgänge](../code-quality/ca2106.md)|Eine Methode bestätigt eine Berechtigung, und es werden keine Sicherheitsüberprüfungen für den Aufrufer durchgeführt. Das Gewähren einer Sicherheitsberechtigung ohne Sicherheitsüberprüfungen durchzuführen, kann ein ausnutzbares Sicherheitsrisiko in Code hinterlassen.|
|[CA2107: Verwendung von Deny und PermitOnly überprüfen](../code-quality/ca2107.md)|Die PermitOnly-Methode und die CodeAccessPermission. Deny-Sicherheitsaktionen sollten nur von denjenigen mit erweiterten Kenntnissen der .NET-Sicherheit verwendet werden. Code, in dem diese Sicherheitsaktionen verwendet werden, sollte einer Sicherheitsüberprüfung unterzogen werden.|
|[CA2108: Deklarative Sicherheit auf Werttypen überprüfen](../code-quality/ca2108.md)|Ein öffentlicher oder geschützter Werttyp wird durch Datenzugriff oder Linkaufrufe gesichert.|
|[CA2109: Sichtbare Ereignishandler überprüfen](../code-quality/ca2109.md)|Eine öffentliche oder geschützte Ereignisbehandlungsmethode wurde erkannt. Ereignisbehandlungsmethoden sollten nur dann verfügbar gemacht werden, wenn dies absolut notwendig ist.|
|[CA2111: Zeiger sollten nicht sichtbar sein](../code-quality/ca2111.md)|Ein Zeiger ist nicht privat, intern oder schreibgeschützt. Bösartiger Code kann den Wert des Zeigers ändern und damit potenziell Zugriffe auf beliebige Speicherbereiche ermöglichen oder Anwendungs- bzw. Systemfehler verursachen.|
|[CA2112: Gesicherte Typen sollten keine Felder verfügbar machen](../code-quality/ca2112.md)|Ein öffentlicher oder geschützter Typ enthält öffentliche Felder und wird durch Linkaufrufe gesichert. Wenn Code auf eine Instanz eines Typs zugreifen muss, der durch einen Linkaufruf gesichert ist, muss der Code für den Zugriff auf die Felder des Typs nicht die Anforderungen des Linkaufrufs erfüllen.|
|[CA2114: Methodensicherheit sollte Superset des Typs sein](../code-quality/ca2114.md)|Eine Methode sollte bei der gleichen Aktion nicht sowohl auf einer Methodenebene als auch auf einer Typebene deklarative Sicherheit aufweisen.|
|[CA2115: GC.KeepAlive beim Verwenden systemeigener Ressourcen aufrufen](../code-quality/ca2115.md)|Diese Regel erkennt Fehler, die auftreten können, wenn eine nicht verwaltete Ressource freigegeben wird, während sie in nicht verwaltetem Code noch verwendet wird.|
|[CA2116: APTCA-Methoden sollten nur APTCA-Methoden aufrufen](../code-quality/ca2116.md)|Wenn eine voll vertrauenswürdige Assembly über das APTCA-Attribut (AllowPartiallyTrustedCallers) verfügt und die Assembly Code in einer anderen Assembly ausführt, die keine teilweise vertrauenswürdigen Aufrufer zulässt, kann diese Sicherheitslücke ausgenutzt werden.|
|[CA2117: APTCA-Typen sollten nur APTCA-Basistypen erweitern](../code-quality/ca2117.md)|Wenn das APTCA-Attribut (AllowPartiallyTrustedCallers) in einer voll vertrauenswürdigen Assembly vorhanden ist und ein in der Assembly enthaltener Typ von einem Typ erbt, der nur voll vertrauenswürdige Aufrufer zulässt, können Sicherheitslücken entstehen, die sich für Angriffe ausnutzen lassen.|
|[CA2118: Überprüfen der Verwendung von SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118.md)|SuppressUnmanagedCodeSecurityAttribute ändert das Standardverhalten des Sicherheitssystems für Member, die nicht verwalteten Code ausführen, der COM-Interop oder Plattformaufrufe verwendet. Dieses Attribut wird hauptsächlich verwendet, um die Leistung zu erhöhen. Der Leistungszuwachs geht jedoch mit beträchtlichen Sicherheitsrisiken einher.|
|[CA2119: Methoden versiegeln, die die Bedingungen privater Schnittstellen erfüllen](../code-quality/ca2119.md)|Ein vererbbarer öffentlicher Typ stellt eine überschreibbare Methodenimplementierung einer internen Schnittstelle (Friend in Visual Basic) bereit. Um einen Verstoß gegen diese Regel zu beheben, verhindern Sie, dass die Methode außerhalb der Assembly überschrieben wird.|
|[CA2120: Sichere Serialisierungskonstruktoren](../code-quality/ca2120.md)|Dieser Typ verfügt über einen Konstruktor, der ein System.Runtime.Serialization.SerializationInfo-Objekt und ein System.Runtime.Serialization.StreamingContext-Objekt (die Signatur des Serialisierungskonstruktors) akzeptiert. Dieser Konstruktor ist nicht durch eine Sicherheitsüberprüfung gesichert. Dagegen ist mindestens einer der normalen Konstruktoren des Typs gesichert.|
|[CA2121: Statische Konstruktoren sollten privat sein](../code-quality/ca2121.md)|Das System ruft den statischen Konstruktor auf, bevor die erste Instanz des Typs erzeugt wird bzw. bevor auf irgendwelche statischen Member verwiesen wird. Wenn ein statischer Konstruktor nicht privat ist, kann er von Code aufgerufen werden, der nicht Systemcode ist. Je nach den Operationen innerhalb des Konstruktors kann dies zu unerwartetem Verhalten führen.|
|[CA2122: Methoden mit Linkaufrufen nicht indirekt verfügbar machen](../code-quality/ca2122.md)|Ein öffentlicher oder geschützter Member enthält Linkaufrufe und wird von einem Member aufgerufen, der keine Sicherheitsüberprüfungen ausführt. Ein Linkaufruf überprüft nur die Berechtigungen des unmittelbaren Aufrufers.|
|[CA2123: Überschreibungslinkaufrufe sollten mit der Basis identisch sein](../code-quality/ca2123.md)|Durch diese Regel wird eine Methode mit ihrer Basismethode verglichen. Bei dieser handelt es sich entweder um eine Schnittstelle oder um eine virtuelle Methode in einem anderen Typ. Anschließend werden die Linkaufruf mit denen der Schnittstelle bzw. virtuellen Methode verglichen. Bei einem Verstoß gegen diese Regel kann ein böswilliger Aufrufer den Linkaufruf einfach durch Aufruf der ungesicherten Methode umgehen.|
|[CA2124: Anfällige finally-Klauseln mit äußerem try-Block umschließen](../code-quality/ca2124.md)|Eine öffentliche oder geschützte Methode enthält einen try/finally-Block. Durch den finally-Block, der nicht wiederum in einen finally-Block eingeschlossen ist, wird der Sicherheitszustand zurückgesetzt.|
|[CA2126: Typlinkaufrufe erfordern Vererbungsanforderungen](../code-quality/ca2126.md)|Ein öffentlicher unversiegelter Typ wird durch einen Linkaufruf geschützt und verfügt über eine überschreibbare Methode. Weder der Typ noch die Methode wird mit einer Vererbungsanforderung geschützt.|
|[CA2130: Sicherheitskritische Konstanten sollten transparent sein](../code-quality/ca2130.md)|Transparenzerzwingung wird nicht für konstante Werte erzwungen, da Compiler konstante Werte inline verwenden, damit zur Laufzeit keine Suche erforderlich ist. Konstante Felder sollten sicherheitstransparent sein, damit Codebearbeiter nicht davon ausgehen, dass dieser transparente Code nicht auf die Konstante zugreifen kann.|
|[CA2131: Sicherheitskritische Typen dürfen nicht an Typäquivalenz beteiligt sein](../code-quality/ca2131.md)|Ein Typ ist an typäquivalenz beteiligt, und der Typ selbst oder ein Member oder Feld des Typs ist mit dem SecurityCriticalAttribute-Attribut markiert. Diese Regel wird für alle wichtigen Typen ausgelöst oder für Typen, die wichtige Methoden oder Felder enthalten, die an der Typäquivalenz beteiligt sind. Wenn die CLR einen derartigen Typ erkennt, wird dieser zur Laufzeit nicht geladen, und es wird eine TypeLoadException ausgelöst. In der Regel wird diese Regel nur ausgelöst, wenn Benutzer Typäquivalenz manuell implementieren und die Typäquivalenz nicht von tlbimp und den Compilern ausführen lassen.|
|[CA2132: Standardkonstruktoren müssen mindestens so kritisch sein wie die Standardkonstruktoren des Basistyps](../code-quality/ca2132.md)|Typen und Member mit dem SecurityCriticalAttribute können nicht vom Silverlight-Anwendungscode verwendet werden. Sicherheitsrelevante Typen und Member können nur von vertrauenswürdigem Code in der .NET Framework for Silverlight-Klassenbibliothek verwendet werden. Da eine öffentliche oder geschützte Konstruktion in einer abgeleiteten Klasse mindestens die gleiche Transparenz aufweisen muss wie die zugehörige Basisklasse, können Klassen in einer Anwendung nicht von Klassen abgeleitet werden, die als SecurityCritical markiert sind.|
|[CA2133: Delegaten müssen an Methoden mit konsistenter Transparenz gebunden werden](../code-quality/ca2133.md)|Diese Warnung wird für eine Methode ausgelöst, die einen mit dem SecurityCriticalAttribute markierten Delegaten an eine Methode bindet, die transparent oder mit dem SecuritySafeCriticalAttribute markiert ist. Die Warnung wird auch für eine Methode ausgelöst, die einen transparenten oder sicherheitsrelevanten Delegaten an eine wichtige Methode bindet.|
|[CA2134: Methoden müssen beim Überschreiben von Basismethoden eine konsistente Transparenz wahren](../code-quality/ca2134.md)|Diese Regel wird ausgelöst, wenn eine mit dem SecurityCriticalAttribute markierte Methode eine Methode überschreibt, die transparent oder mit dem SecuritySafeCriticalAttribute markiert ist. Die Regel wird auch ausgelöst, wenn eine transparente oder mit dem SecuritySafeCriticalAttribute markierte Methode eine Methode überschreibt, die mit dem SecurityCriticalAttribute markiert ist. Die Regel wird angewendet, wenn eine virtuelle Methode überschrieben oder eine Schnittstelle implementiert wird.|
|[CA2135: Assemblys der Stufe 2 dürfen keine LinkDemands enthalten](../code-quality/ca2135.md)|LinkDemands sind im Sicherheitsregelsatz der Ebene 2 veraltet. Markieren Sie, statt LinkDemands zur Erzwingung von Sicherheit zur JIT-Kompilierungszeit zu erzwingen, die Methoden, Typen und Felder mit dem SecurityCriticalAttribute-Attribut.|
|[CA2136: Member dürfen keine miteinander in Konflikt stehenden Transparenzanmerkungen aufweisen](../code-quality/ca2136.md)|Transparenzattribute werden von größeren Codeelementen bis hin zu kleineren Elementen übernommen. Die Transparenzattribute von Codeelementen mit größerem Umfang haben Vorrang vor Transparenzattributen von Codeelementen, die im ersten Element enthalten sind. Eine Klasse, die mit dem SecurityCriticalAttribute-Attribut markiert ist, kann z. B. keine Methode enthalten, die mit dem SecuritySafeCriticalAttribute-Attribut markiert ist.|
|[CA2137: Transparente Methoden dürfen nur überprüfbare IL enthalten](../code-quality/ca2137.md)|Eine Methode enthält nicht überprüfbaren Code oder gibt einen Typ nach Verweis zurück. Diese Regel wird für Versuche durch sicherheitstransparenten Code ausgelöst, nicht überprüfbare MSIL (Microsoft Intermediate Language) auszuführen. Die Regel enthält jedoch kein vollständiges IL-Prüfmodul und verwendet stattdessen Heuristik, um die meisten Verletzungen der MSIL-Überprüfung abzufangen.|
|[CA2138: Transparente Methoden dürfen keine Methoden mit dem SuppressUnmanagedCodeSecurity-Attribut aufrufen](../code-quality/ca2138.md)|Eine sicherheitstransparente Methode ruft eine Methode auf, die mit dem SuppressUnmanagedCodeSecurityAttribute-Attribut markiert ist.|
|[CA2139: Transparente Methoden dürfen das HandleProcessCorruptingExceptions-Attribut nicht verwenden](../code-quality/ca2139.md)|Diese Regel wird für jede Methode ausgelöst, die transparent ist und versucht, eine Prozess beschädigte Ausnahme mithilfe des "processprocesscorruptedstateexceptionsattribute"-Attributs zu behandeln. Eine Ausnahme bei der Prozess Beschädigung ist eine CLR-Version 4,0-Ausnahme Klassifizierung von Ausnahmen, z. b. <xref:System.AccessViolationException>. Das HandleProcessCorruptedStateExceptionsAttribute-Attribut darf nur von sicherheitskritischen Methoden verwendet werden und wird ignoriert, wenn es für eine transparente Methode übernommen wird.|
|[CA2140: Transparenter Code darf nicht auf sicherheitskritische Elemente verweisen](../code-quality/ca2140.md)|Mit SecurityTransparentAttribute markierte Methoden rufen nicht öffentliche Member auf, die als SecurityCritical markiert sind. Diese Regel analysiert alle Methoden und Typen in einer Assembly, die gemischt transparent und kritisch ist, und kennzeichnet alle Aufrufe aus transparentem Code an nicht öffentlichen kritischen Code, der nicht als SecurityTreatAsSafe gekennzeichnet ist.|
|[CA2141: Transparente Methoden dürfen keine LinkDemands erfüllen](../code-quality/ca2141.md)|Eine sicherheitstransparente Methode ruft eine Methode in einer Assembly auf, die nicht mit dem APTCA-Attribut (AllowPartiallyTrustedCallersAttribute) markiert ist, oder eine sicherheitstransparente Methode erfüllt einen LinkDemand für einen Typ oder eine Methode.|
|[CA2142: Transparenter Code darf nicht mit LinkDemands geschützt werden](../code-quality/ca2142.md)|Diese Regel wird für transparente Methoden ausgelöst, die einen Zugriff durch LinkDemands erfordern. Sicherheitstransparenter Code sollte nicht für das Überprüfen der Sicherheit einer Operation zuständig sein und sollte daher keine Berechtigungen fordern.|
|[CA2143: Transparente Methoden dürfen keine Sicherheitsanforderungen verwenden](../code-quality/ca2143.md)|Sicherheitstransparenter Code sollte nicht für das Überprüfen der Sicherheit einer Operation zuständig sein und sollte daher keine Berechtigungen fordern. Sicherheitstransparenter Code sollte mithilfe von vollständigen Anforderungen Sicherheitsentscheidungen fällen, und sicherheitskritischer Code sollte für die vollständige Anforderung nicht auf transparentem Code beruhen.|
|[CA2144: Transparenter Code darf keine Assemblys aus Bytearrays laden](../code-quality/ca2144.md)|Die Sicherheitsüberprüfung für transparenten Code ist nicht so umfassend wie die Sicherheitsüberprüfung für wichtigen Code, da in transparentem Code keine sicherheitsrelevanten Aktionen ausgeführt werden können. Aus einem Bytearray geladene Assemblys werden in transparentem Code eventuell nicht erkannt, und dieses Bytearray könnte wichtigen oder sicherheitsgeschützten Code enthalten, der überwacht werden muss.|
|[CA2145: Transparente Methoden dürfen nicht mit dem SuppressUnmanagedCodeSecurity-Attribut versehen werden](../code-quality/ca2145.md)|Methoden, die mit dem SuppressUnmanagedCodeSecurityAttribute-Attribut ergänzt wurden, weisen jeder aufrufenden Methode einen impliziten LinkDemand zu. Dieser LinkDemand erfordert, dass der aufrufende Code sicherheitskritisch ist. Durch das Markieren der Methode, die SuppressUnmanagedCodeSecurity verwendet, mit dem SecurityCriticalAttribute-Attribut wird diese Anforderung für Aufrufer der Methode leichter ersichtlich.|
|[CA2146: Typen müssen mindestens genauso kritisch sein wie ihre Basistypen und Schnittstellen](../code-quality/ca2146.md)|Diese Regel wird ausgelöst, wenn ein abgeleiteter Typ über ein Sicherheitstransparenzattribut verfügt, das nicht so wichtig wie der Basistyp oder die implementierte Schnittstelle ist. Nur wichtige Typen können von wichtigen Basistypen abgeleitet werden oder kritische Schnittstellen implementieren, und nur kritische oder sicherheitskritische Typen können von sicherheitskritischen Basistypen abgeleitet werden oder sicherheitskritische Schnittstellen implementieren.|
|[CA2147: Transparente Methoden dürfen keine Sicherheitsassertionen verwenden](../code-quality/ca2147.md)|Mit dieser Regel werden alle Methoden und Typen in einer Assembly analysiert, die entweder zu 100 % aus transparentem Code oder aus einer Kombination aus transparentem und kritischem Code besteht. Anschließend werden alle deklarativen oder imperativen Verwendungen von Assert gekennzeichnet.|
|[CA2149: Transparente Methoden dürfen keine Aufrufe in nativen Code durchführen](../code-quality/ca2149.md)|Diese Regel wird für jede transparente Methode ausgelöst, die direkt in nativem Code aufruft, z. b. über einen P/-Aufruf. Verstöße gegen diese Regel führen im Transparenzmodell der Ebene 2 zu einer MethodAccessException und im Transparenzmodell der Ebene 1 zu einer vollständigen Anforderung für UnmanagedCode.|
|[CA2151: Felder mit kritischen Typen sollten sicherheitskritisch sein](../code-quality/ca2151.md)|Um sicherheitskritische Typen zu verwenden, muss der Code, der auf den Typ verweist, entweder sicherheitskritisch oder sicherungskritisch sein. Dies gilt auch, wenn der Verweis indirekt ist. Daher kann ein sicherheitstransparentes oder sicherungskritisches Feld irreführend sein, denn transparenter Code kann trotzdem nicht auf das Feld zugreifen.|
|[CA2153: Verhindern, dass Ausnahmen bei Beschädigungen verarbeitet werden](../code-quality/ca2153.md)|[Ausnahmen bei Beschädigungen (Corrupted State Exceptions, CSE)](https://msdn.microsoft.com/magazine/dd419661.aspx) weisen auf eine Speicherbeschädigung innerhalb des Prozesses hin. Diese abzufangen, statt einen Absturz des Prozesses zuzulassen, führt zu Sicherheitsrisiken, falls ein Angreifer einen Exploit in den beschädigten Speicherbereich einschleusen kann.|
|[CA2300: unsicheres Deserialisierungsprogramm BinaryFormatter verwenden](../code-quality/ca2300.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2301: BinaryFormatter. Deserialize ohne erstes Festlegen von BinaryFormatter. Binder aufrufen](../code-quality/ca2301.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2302: Stellen Sie sicher, dass BinaryFormatter. Binder vor dem Aufrufen von BinaryFormatter. Deserialize festgelegt ist.](../code-quality/ca2302.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2305: nicht sicheres Deserialisierungsprogramm-losformatierung verwenden](../code-quality/ca2305.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2310: Verwenden Sie nicht den unsicheren Deserialisierer NetDataContractSerializer.](../code-quality/ca2310.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2311: deserialisieren Sie nicht, ohne zuerst NetDataContractSerializer. Binder festzulegen.](../code-quality/ca2311.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2312: Stellen Sie sicher, dass NetDataContractSerializer. Binder vor der Deserialisierung festgelegt ist.](../code-quality/ca2312.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2315: Verwenden Sie nicht unsichere Deserialisierungsprogramm ObjectStateFormatter.](../code-quality/ca2315.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2321: deserialisieren Sie nicht mit JavaScriptSerializer mithilfe eines SimpleTypeResolver.](../code-quality/ca2321.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2322: Stellen Sie sicher, dass JavaScriptSerializer vor der Deserialisierung nicht mit "SimpleTypeResolver" initialisiert wird.](../code-quality/ca2322.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2326: Verwenden Sie nicht "typamehandelt"-Werte außer "None".](../code-quality/ca2326.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2327: nicht unsichere jsonserializersettings verwenden](../code-quality/ca2327.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2328: Stellen Sie sicher, dass "jsonserializersettings" sicher ist.](../code-quality/ca2328.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2329: deserialisieren Sie nicht mit jsonSerializer, indem Sie eine unsichere Konfiguration verwenden.](../code-quality/ca2329.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA2330: Stellen Sie sicher, dass jsonSerializer bei der Deserialisierung eine sichere Konfiguration aufweist.](../code-quality/ca2330.md)|Unsichere deserialisierungssoren sind beim Deserialisieren nicht vertrauenswürdiger Daten anfällig. Ein Angreifer könnte die serialisierten Daten so ändern, dass unerwartete Typen eingefügt werden, um Objekte mit bösartigen Nebeneffekten einzuschleusen.|
|[CA3001: Code für SQL-einschleusungs Sicherheitslücken](../code-quality/ca3001.md)|Beachten Sie beim Arbeiten mit nicht vertrauenswürdigen Eingabe-und SQL-Befehlen, dass SQL-Injection-Angriffe berücksichtigt werden. Ein SQL Injection-Angriff kann bösartige SQL-Befehle ausführen und so die Sicherheit und Integrität Ihrer Anwendung beeinträchtigen.|
|[CA3002: Code für XSS-Sicherheitsrisiken überprüfen](../code-quality/ca3002.md)|Beachten Sie beim Arbeiten mit nicht vertrauenswürdigen Eingaben aus Webanforderungen, dass XSS-Angriffe (Cross-Site Scripting) berücksichtigt werden. Ein XSS-Angriff fügt nicht vertrauenswürdige Eingaben in die unformatierte HTML-Ausgabe ein, sodass der Angreifer bösartige Skripts ausführen oder den Inhalt auf der Webseite in böswilliger Absicht ändern kann.|
|[CA3003: Code für Sicherheitsrisiken bei der Datei Pfad Injektion](../code-quality/ca3003.md)|Wenn Sie mit nicht vertrauenswürdigen Eingaben aus Webanforderungen arbeiten, achten Sie darauf, benutzergesteuerte Eingaben beim Angeben von Pfaden zu Dateien zu verwenden.|
|[CA3004: Code zur Offenlegung von Sicherheitsrisiken überprüfen](../code-quality/ca3004.md)|Die Offenlegung von Ausnahme Informationen bietet Angreifern Einblicke in die internale Ihrer Anwendung, die Angreifern bei der Suche nach anderen Sicherheitsrisiken helfen können.|
|[CA3006: Überprüfen von Code auf Sicherheitsanfälligkeiten bei der Prozess Eingabe](../code-quality/ca3006.md)|Beachten Sie bei der Arbeit mit nicht vertrauenswürdigen Eingaben, dass Befehls Injection-Angriffe berücksichtigt werden. Ein Befehl zum Einschleusen von Befehlen kann bösartige Befehle auf dem zugrunde liegenden Betriebssystem ausführen und so die Sicherheit und Integrität des Servers beeinträchtigen.|
|[CA3007: Code für offene Umleitungs Sicherheitslücken überprüfen](../code-quality/ca3007.md)|Beachten Sie bei der Arbeit mit nicht vertrauenswürdigen Eingaben die Sicherheitsrisiken offener Umleitung. Ein Angreifer kann eine offene Umleitungs Anfälligkeit ausnutzen, um die Darstellung einer legitimen URL mithilfe Ihrer Website zu versehen, aber einen nicht ahnenden Besucher an eine phishingwebseite oder eine andere böswillige Webseite umzuleiten.|
|[CA3008: Code für XPath-Injection-Sicherheitsrisiken überprüfen](../code-quality/ca3008.md)|Beachten Sie bei der Arbeit mit nicht vertrauenswürdigen Eingaben die XPath-Injection-Angriffe. Das Erstellen von XPath-Abfragen mithilfe nicht vertrauenswürdiger Eingaben kann es einem Angreifer ermöglichen, die Abfrage bösartig zu manipulieren, um ein unbeabsichtigtes Ergebnis zurückzugeben, und möglicherweise den Inhalt der abgefragten XML-Daten offenzulegen.|
|[CA3009: Code für XML-einschleusungs Sicherheitslücken](../code-quality/ca3009.md)|Beachten Sie bei der Arbeit mit nicht vertrauenswürdigen Eingaben, dass XML-Injection-Angriffe berücksichtigt werden.|
|[CA3010: Code für XAML Injection-Sicherheitsrisiken überprüfen](../code-quality/ca3010.md)|Beachten Sie bei der Arbeit mit nicht vertrauenswürdigen Eingaben XAML Injection-Angriffe. XAML ist eine Markupsprache, die Objektinstanziierung und -ausführung direkt darstellt. Dies bedeutet, dass in XAML erstellte Elemente mit Systemressourcen interagieren können (z. b. Netzwerk Zugriff und Dateisystem-e/a).|
|[CA3011: Überprüfen von Code auf Sicherheitsanfälligkeiten der dll](../code-quality/ca3011.md)|Wenn Sie mit nicht vertrauenswürdigen Eingaben arbeiten, achten Sie darauf, nicht vertrauenswürdigen Code zu laden. Wenn Ihre Webanwendung nicht vertrauenswürdigen Code lädt, kann ein Angreifer möglicherweise böswillige DLLs in Ihren Prozess einfügen und bösartigen Code ausführen.|
|[CA3012: Code für Regex Injection-Sicherheitsrisiken überprüfen](../code-quality/ca3012.md)|Beachten Sie bei der Arbeit mit nicht vertrauenswürdigen Eingaben die Regex Injection-Angriffe. Ein Angreifer kann eine Regex-Injektion verwenden, um einen regulären Ausdruck in böswilliger Weise zu ändern, damit der Regex unbeabsichtigte Ergebnisse findet oder der Regex übermäßige CPU beansprucht, was zu einem Denial-of-Service-Angriff führt.|
|[CA3061: Schema nicht über URL hinzufügen](../code-quality/ca3061.md)|Verwenden Sie die unsichere Überladung der Add-Methode nicht, da Sie gefährliche externe Verweise verursachen kann.|
|[CA3075: Unsichere DTD-Verarbeitung](../code-quality/ca3075.md)|Wenn Sie unsichere DTDProcessing-Instanzen verwenden oder auf externe Entitätsquellen verweisen, kann der Parser unter Umständen nicht vertrauenswürdige Eingaben akzeptieren und Angreifern vertrauliche Informationen offenlegen.|
|[CA3076: Unsichere XSLT-Skriptausführung](../code-quality/ca3076.md)|Wenn Sie Extensible Stylesheets Language Transformations (XSLT) ungesichert in .NET-Anwendungen ausführen, könnte der Prozessor möglicherweise nicht vertrauenswürdige URI-Verweise auflösen, wodurch Angreifern sensible Informationen offengelegt werden könnten, was wiederum zu Denial-of-Service- und Cross-Site-Angriffen führen kann.|
|[CA3077: Unsichere Verarbeitung in API-Design, XML-Dokument und XML-Textreader](../code-quality/ca3077.md)|Beim Entwerfen einer von XMLDocument und XMLTextReader abgeleiteten API sollten Sie DtdProcessing berücksichtigen. Das Verwenden unsicherer DTDProcessing-Instanzen beim Verweisen auf externe Entitätsquellen bzw. bei deren Auflösung oder das Festlegen unsicherer Werte in XML-Code kann zum Offenlegen von Informationen führen.|
|[CA3147: Markieren von Verb Handlern mit validateantiforgerytoken](../code-quality/ca3147.md)|Achten Sie beim Entwerfen eines ASP.NET-MVC-Controllers auf Site übergreifende Anforderungs Fälschungs Angriffe. Mit einem Website übergreifenden Anforderungs Fälschungs Angriff können böswillige Anforderungen von einem authentifizierten Benutzer an Ihren ASP.NET MVC-Controller gesendet werden.|
|[CA5122: P-Invoke-Deklarationen sollten nicht sicherungskritisch sein](../code-quality/ca5122.md)|Methoden werden als SecuritySafeCritical markiert, wenn sie einen sicherheitsrelevanten Vorgang ausführen. Sie können jedoch auch mit transparentem Code verwendet werden. Transparenter Code ruft systemeigenen Code möglicherweise nie direkt mit P/Invoke auf. Wenn daher P/Invoke als sicherungskritisch markiert wird, kann es nicht von transparentem Code aufgerufen werden, was bei der Sicherheitsanalyse irreführend ist.|
|[CA5361: die SChannel-Verwendung der starken Kryptografie nicht deaktivieren](../code-quality/ca5361.md)|Wenn Sie `Switch.System.Net.DontEnableSchUseStrongCrypto` auf `true` festlegen, wird die Kryptografie für ausgehende Transport Layer Security Verbindungen (TLS) schwächer. Schwächere Kryptografie kann die Vertraulichkeit der Kommunikation zwischen Ihrer Anwendung und dem Server beeinträchtigen, sodass Angreifer die Möglichkeit erhalten, sensible Daten besser zu löschen.|
|[CA5363: Anforderungs Validierung nicht deaktivieren](../code-quality/ca5363.md)|Die Anforderungs Validierung ist eine Funktion in ASP.net, die HTTP-Anforderungen untersucht und bestimmt, ob Sie potenziell gefährlichen Inhalt enthalten, der zu Injection-Angriffen führen kann, einschließlich Website übergreifender Skripts.|
|[CA5364: keine veralteten Sicherheitsprotokolle verwenden](../code-quality/ca5364.md)|Transport Layer Security (TLS) sichert die Kommunikation zwischen Computern, in der Regel mit HTTPS (Hypertext Transfer Protocol Secure). Ältere Protokoll Versionen von TLS sind weniger sicher als TLS 1,2 und TLS 1,3 und haben wahrscheinlich neue Sicherheitsrisiken. Vermeiden Sie ältere Protokoll Versionen, um Risiken zu minimieren.|
|[CA5369: XmlReader für die Deserialisierung verwenden](../code-quality/ca5369.md)|Die Verarbeitung von nicht vertrauenswürdigen DTD-und XML-Schemas kann das Laden gefährlicher externer Verweise ermöglichen, das durch die Verwendung eines XmlReader mit einem sicheren Konflikt Löser oder durch deaktivierte DTD-und XML-Inline Schema Verarbeitung eingeschränkt werden sollte.|
|[CA5370: XmlReader zum Überprüfen des Readers verwenden](../code-quality/ca5370.md)|Die Verarbeitung von nicht vertrauenswürdigen DTD-und XML-Schemas kann das Laden gefährlicher externer Verweise ermöglichen. Dieses gefährliche laden kann durch die Verwendung eines XmlReader mit einem sicheren Konflikt Löser oder durch deaktivierte DTD-und XML-Inline Schema Verarbeitung eingeschränkt werden.|
|[CA5371: XmlReader für Schema Lesevorgang verwenden](../code-quality/ca5371.md)|Die Verarbeitung von nicht vertrauenswürdigen DTD-und XML-Schemas kann das Laden gefährlicher externer Verweise ermöglichen. Dies wird durch die Verwendung eines XmlReader mit einem sicheren Konflikt Löser oder mit deaktivierter DTD-und XML-Inline Schema Verarbeitung eingeschränkt.|
|[CA5372: XmlReader für XPathDocument verwenden](../code-quality/ca5372.md)|Beim Verarbeiten von XML aus nicht vertrauenswürdigen Daten können gefährliche externe Verweise geladen werden, die durch die Verwendung eines XmlReader mit einem sicheren Konflikt Löser oder deaktivierter DTD-Verarbeitung eingeschränkt werden können.|
|[CA5373: keine veraltete schlüsselabderivationsfunktion verwenden](../code-quality/ca5373.md)|Diese Regel erkennt den Aufruf von Methoden der schwachen Schlüssel Ableitung <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> und `Rfc2898DeriveBytes.CryptDeriveKey`. <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> hat einen schwachen Algorithmus PBKDF1 verwendet.|
|[CA5378: servicepointmanagersecurityprotokolls nicht deaktivieren](../code-quality/ca5378.md)|Wenn Sie `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` auf `true` festlegen, werden die (WCF)-Transport Layer Security (WCF)-Verbindungen von Windows Communication Framework mithilfe von TLS 1,0 beschränkt. Diese Version von TLS wird als veraltet markiert.|
|[CA5380: Zertifikate nicht zum Stamm Speicher hinzufügen](../code-quality/ca5380.md)|Diese Regel erkennt Code, der ein Zertifikat in den Zertifikat Speicher für vertrauenswürdige Stamm Zertifizierungsstellen einfügt. Standardmäßig ist der Zertifikat Speicher für vertrauenswürdige Stamm Zertifizierungsstellen mit einer Gruppe von öffentlichen Zertifizierungsstellen konfiguriert, die die Anforderungen des Microsoft-Programms für Stamm Zertifikate erfüllt haben.|
|[CA5381: sicherstellen, dass Zertifikate nicht zum Stamm Speicher hinzugefügt werden](../code-quality/ca5381.md)|Mit dieser Regel wird Code erkannt, der potenziell ein Zertifikat in den Zertifikat Speicher für vertrauenswürdige Stamm Zertifizierungsstellen einfügt. Standardmäßig ist der Zertifikat Speicher für vertrauenswürdige Stamm Zertifizierungsstellen mit einer Reihe von öffentlichen Zertifizierungsstellen (CAS) konfiguriert, die die Anforderungen des Microsoft-Programms für Stamm Zertifikate erfüllen.|
|[CA5386: vermeiden Sie die hart Codierung von SecurityProtocolType-Werten.](../code-quality/ca5386.md)|Transport Layer Security (TLS) sichert die Kommunikation zwischen Computern, in der Regel mit HTTPS (Hypertext Transfer Protocol Secure). Die Protokoll Versionen TLS 1,0 und TLS 1,1 sind veraltet, TLS 1,2 und TLS 1,3 sind jedoch aktuell. In Zukunft können TLS 1,2 und TLS 1,3 als veraltet eingestuft werden. Um sicherzustellen, dass Ihre Anwendung sicher bleibt, vermeiden Sie das hart codieren einer Protokollversion und das Ziel mindestens .NET Framework v-4.7.1.|
|[CA5389: der Pfad des Archiv Elements wird nicht zum Ziel Dateisystempfad hinzugefügt.](../code-quality/ca5389.md)|Der Dateipfad kann relativ sein und kann dazu führen, dass der Dateisystem Zugriff außerhalb des erwarteten Ziel Pfads für das Dateisystem ist, was zu schädlichen Konfigurationsänderungen und Remote Codeausführung über die Methode "Lay-and-Wait" führt.|
|[CA5397: Verwenden Sie keine veralteten sslprotokolle-Werte.](../code-quality/ca5397.md)|ransport Layer Security (TLS) sichert die Kommunikation zwischen Computern, in der Regel mit HTTPS (Hypertext Transfer Protocol Secure). Ältere Protokoll Versionen von TLS sind weniger sicher als TLS 1,2 und TLS 1,3 und haben wahrscheinlich neue Sicherheitsrisiken. Vermeiden Sie ältere Protokoll Versionen, um Risiken zu minimieren.|
|[CA5398: hart codierte sslprotokolle-Werte vermeiden](../code-quality/ca5398.md)|Transport Layer Security (TLS) sichert die Kommunikation zwischen Computern, in der Regel mit HTTPS (Hypertext Transfer Protocol Secure). Die Protokoll Versionen TLS 1,0 und TLS 1,1 sind veraltet, TLS 1,2 und TLS 1,3 sind jedoch aktuell. In Zukunft können TLS 1,2 und TLS 1,3 als veraltet eingestuft werden. Vermeiden Sie das hart codieren einer Protokollversion, um sicherzustellen, dass Ihre Anwendung sicher bleibt.|
