---
title: C6211
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6211
helpviewer_keywords:
- C6211
ms.assetid: 9b68243b-534c-4a05-b789-bb155dfcba1e
author: mikeblome
ms.author: mblome
manager: wpickett
ms.workload:
- multiple
ms.openlocfilehash: c5976b16cea8e4dcf90d864e08e78977b0ce1a1e
ms.sourcegitcommit: 94b3a052fb1229c7e7f8804b09c1d403385c7630
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/23/2019
ms.locfileid: "62782572"
---
# <a name="c6211"></a>C6211
Warnung C6211: Speicherverlust \<Zeiger > aufgrund einer Ausnahme. Verwenden Sie einen lokalen Catch-Block, um den Arbeitsspeicher zu bereinigen.

 Diese Warnung gibt an, dass, zugeordneter Arbeitsspeicher nicht freigegeben werden wird, wenn eine Ausnahme ausgelöst wird. Die Anweisung am Ende des Pfads konnte eine Ausnahme ausgelöst. Der Analyzer überprüft auf diese Bedingung, wenn die `_Analysis_mode_(_Analysis_local_leak_checks_)`-SAL-Anmerkung angegeben wird. Standardmäßig ist diese Anmerkung für den Windows-Kernelmoduscode (Treiber) angegeben. Weitere Informationen zu SAL-Anmerkungen finden Sie unter [Verwenden von SAL-Anmerkungen zum Reduzieren von C/C++-Codefehlern](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md).

## <a name="example"></a>Beispiel
 Der folgende Code generiert diese Warnung, weil eine Ausnahme während der zweiten Zuordnung und somit auch Verlust der ersten Zuordnung ausgelöst werden kann, oder eine konnte Ausnahme an einer beliebigen Stelle im Code, der durch dargestellt wird die "`code ...`" Kommentar und somit auch Beide Zuordnungen zur Offenlegung.

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>

_Analysis_mode_(_Analysis_local_leak_checks_)
void f( )
{
    char *p1 = new char[10];
    char *p2 = new char[10];

    // code ...

    delete[] p2;
    delete[] p1;
}
```

 Um die gleichen Zuordnungsfunktionen verwenden und dieses Problem zu beheben, fügen Sie einen Ausnahmehandler hinzu:

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>
#include <new>
#include <iostream>
using namespace std;

_Analysis_mode_(_Analysis_local_leak_checks_)

void f()
{
    char *p1 = nullptr;
    char *p2 = nullptr;

    try
    {
        p1 = new char[10];
        p2 = new char[10];

        // code ...

        delete [] p2;
        delete [] p1;
    }
    catch (const bad_alloc& ba)
    {
        cout << ba.what() << endl;
        delete [] p2;
        delete [] p1;
    }
    // code ...
}
```

 Um diese Arten von potenziellen Verlusten vollständig zu vermeiden, verwenden Sie die Mechanismen, die von der C++-Standardvorlagenbibliothek Library (STL) bereitgestellt werden. Dazu gehören ["shared_ptr"](/cpp/standard-library/shared-ptr-class), [Unique_ptr](/cpp/standard-library/unique-ptr-class), und [Vektor](/cpp/standard-library/vector). Weitere Informationen finden Sie unter [intelligente Zeiger](/cpp/cpp/smart-pointers-modern-cpp) und [C++-Standardbibliothek](/cpp/standard-library/cpp-standard-library-reference).

```cpp
// cl.exe /analyze /c /EHsc /nologo /W4
#include <sal.h>
#include <vector>
#include <memory>

using namespace std;

_Analysis_mode_(_Analysis_local_leak_checks_)

void f( )
{
    // use 10-element vectors in place of char[10]
    vector<char> v1;
    vector<char> v2;

    for (int i=0; i<10; ++i) {
        v1.push_back('a');
        v2.push_back('b');
    }
    // code ...

    // use unique_ptr if you still want char[10]
    unique_ptr<char[]> a1(new char[10]);
    unique_ptr<char[]> a2(new char[10]);

    // code ...

    // No need for delete; vector and unique_ptr
    // clean up when out of scope.
}
```

## <a name="see-also"></a>Siehe auch
 [C++-Ausnahmebehandlung](/cpp/cpp/cpp-exception-handling)