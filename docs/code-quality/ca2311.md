---
title: 'CA2311: deserialisieren Sie nicht, ohne zuerst NetDataContractSerializer. Binder festzulegen.'
ms.date: 05/01/2019
ms.topic: reference
author: dotpaul
ms.author: paulming
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
f1_keywords:
- CA2311
- DoNotDeserializeWithoutFirstSettingNetDataContractSerializerBinder
ms.openlocfilehash: e2dae7e55d4ffec278eb0f7144873fe8e766623c
ms.sourcegitcommit: c222052906362bf1a3762ec4d4623170e4e06702
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 12/04/2019
ms.locfileid: "74810103"
---
# <a name="ca2311-do-not-deserialize-without-first-setting-netdatacontractserializerbinder"></a>CA2311: deserialisieren Sie nicht, ohne zuerst NetDataContractSerializer. Binder festzulegen.

|||
|-|-|
|TypeName|DoNotDeserializeWithoutFirstSettingNetDataContractSerializerBinder|
|CheckId|CA2311|
|Kategorie|Microsoft.Security|
|Unterbrechende Änderung|Nicht unterbrechend|

## <a name="cause"></a>Ursache

Eine <xref:System.Runtime.Serialization.NetDataContractSerializer?displayProperty=nameWithType> Deserialisierungsmethode wurde aufgerufen oder referenziert, ohne dass die <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder>-Eigenschaft festgelegt wurde.

Standardmäßig analysiert diese Regel die gesamte CodeBase, aber dies ist [konfigurierbar](#configurability).

## <a name="rule-description"></a>Regelbeschreibung

[!INCLUDE[insecure-deserializers-description](includes/insecure-deserializers-description-md.md)]

Diese Regel sucht <xref:System.Runtime.Serialization.NetDataContractSerializer?displayProperty=nameWithType> deserialisierungsmethodenaufrufe oder Verweise, wenn <xref:System.Runtime.Serialization.NetDataContractSerializer> nicht über <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder> festgelegt ist. Wenn Sie die Deserialisierung mit <xref:System.Runtime.Serialization.NetDataContractSerializer> unabhängig von der <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder>-Eigenschaft nicht zulassen möchten, deaktivieren Sie diese Regel und [CA2312](ca2312.md), und aktivieren Sie die Regel [CA2310](ca2310.md).

## <a name="how-to-fix-violations"></a>Behandeln von Verstößen

- Verwenden Sie, wenn möglich, stattdessen ein sicheres Serialisierungsprogramm, und **lassen Sie nicht zu, dass ein Angreifer einen beliebigen zu deserialisierenden Typ angibt**. Zu den sichereren serialisierungssoren zählen:
  - <xref:System.Runtime.Serialization.DataContractSerializer?displayProperty=nameWithType>
  - <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer?displayProperty=nameWithType>
  - <xref:System.Web.Script.Serialization.JavaScriptSerializer?displayProperty=nameWithType> verwenden Sie niemals <xref:System.Web.Script.Serialization.SimpleTypeResolver?displayProperty=nameWithType>. Wenn Sie einen Typresolver verwenden müssen, beschränken Sie deserialisierte Typen auf eine erwartete Liste.
  - <xref:System.Xml.Serialization.XmlSerializer?displayProperty=nameWithType>
  - Newtonsoft JSON.net: Verwenden Sie typamehandult. None. Wenn Sie einen anderen Wert für typamehanding verwenden müssen, beschränken Sie deserialisierte Typen auf eine erwartete Liste mit einem benutzerdefinierten iserializationbinder.
  - Protokollpuffer
- Sorgen Sie dafür, dass die serialisierten Daten manipuliert werden. Signieren Sie die serialisierten Daten nach der Serialisierung kryptografisch. Überprüfen Sie vor der Deserialisierung die kryptografische Signatur. Schützen Sie den Kryptografieschlüssel vor der Offenlegung, und entwerfen Sie Schlüssel Drehungen.
- Deserialisierte Typen einschränken. Implementieren Sie eine benutzerdefinierte <xref:System.Runtime.Serialization.SerializationBinder?displayProperty=nameWithType>. Legen Sie vor der Deserialisierung mit <xref:System.Runtime.Serialization.NetDataContractSerializer>die <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder>-Eigenschaft auf eine Instanz des benutzerdefinierten <xref:System.Runtime.Serialization.SerializationBinder>fest. Lösen Sie in der überschriebenen <xref:System.Runtime.Serialization.SerializationBinder.BindToType%2A> Methode, wenn der Typ unerwartet ist, eine Ausnahme aus, um die Deserialisierung zu beenden.

## <a name="when-to-suppress-warnings"></a>Wann sollten Warnungen unterdrückt werden?

[!INCLUDE[insecure-deserializers-common-safe-to-suppress](includes/insecure-deserializers-common-safe-to-suppress-md.md)]

## <a name="configurability"></a>Konfigurierbarkeit

Wenn Sie diese Regel von [FxCop](install-fxcop-analyzers.md) Analyzer (und nicht mit der Legacy Analyse) ausführen, können Sie die Analyse für diese Regel konfigurieren.

### <a name="excluded-symbol-names"></a>Ausgeschlossene Symbolnamen

Sie können konfigurieren, welche Teile Ihrer Codebasis von der Analyse ausgeschlossen werden sollen. Um beispielsweise anzugeben, dass die Regel nicht in einem Code innerhalb von Typen mit dem Namen `MyType`ausgeführt werden soll, fügen Sie das folgende Schlüssel-Wert-Paar zu einer Editor config-Datei in Ihrem Projekt hinzu:

```ini
dotnet_code_quality.CA2311.excluded_symbol_names = MyType
```

Zulässige Symbol namens Formate im Optionswert (durch "|" getrennt):
  - Nur Symbol Name (schließt alle Symbole mit dem Namen ein, unabhängig vom enthaltenden Typ oder Namespace)
  - Voll qualifizierte Namen im [Dokumentations-ID-Format](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)des Symbols. Jeder Symbol Name erfordert ein Symbolart-Präfix, z. b. "M:"-Präfix für Methoden, "T:"-Präfix für Typen, "N:"-Präfix für Namespaces usw.
  - `.ctor` für Konstruktoren und `.cctor` für statische Konstruktoren

Beispiele:

| Optionswert | Summary |
| --- | --- |
|`dotnet_code_quality.CA2311.excluded_symbol_names = MyType` | Entspricht allen Symbolen mit dem Namen "MyType" in der Kompilierung.
|`dotnet_code_quality.CA2311.excluded_symbol_names = MyType1|MyType2` | Entspricht allen Symbolen mit dem Namen "MyType1" oder "MyType2" in der Kompilierung.
|`dotnet_code_quality.CA2311.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Entspricht der bestimmten Methode "MyMethod" mit der angegebenen voll qualifizierten Signatur.
|`dotnet_code_quality.CA2311.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Entspricht den spezifischen Methoden "MyMethod1" und "MyMethod2" mit der entsprechenden voll qualifizierten Signatur.

Sie können all diese Optionen für diese Regel, für alle Regeln oder für alle Regeln in dieser Kategorie (Sicherheit) konfigurieren. Weitere Informationen finden Sie unter [Konfigurieren von FxCop-Analysen](configure-fxcop-analyzers.md).

## <a name="pseudo-code-examples"></a>Pseudo Codebeispiele

### <a name="violation"></a>Verletzung

```csharp
using System;
using System.IO;
using System.Runtime.Serialization;

[DataContract]
public class BookRecord
{
    [DataMember]
    public string Title { get; set; }

    [DataMember]
    public AisleLocation Location { get; set; }
}

[DataContract]
public class AisleLocation
{
    [DataMember]
    public char Aisle { get; set; }

    [DataMember]
    public byte Shelf { get; set; }
}

public class ExampleClass
{
    public BookRecord DeserializeBookRecord(byte[] bytes)
    {
        NetDataContractSerializer serializer = new NetDataContractSerializer();
        using (MemoryStream ms = new MemoryStream(bytes))
        {
            return (BookRecord) serializer.Deserialize(ms);    // CA2311 violation
        }
    }
}
```

```vb
Imports System
Imports System.IO
Imports System.Runtime.Serialization

<DataContract()>
Public Class BookRecord
    <DataMember()>
    Public Property Title As String

    <DataMember()>
    Public Property Location As AisleLocation
End Class

<DataContract()>
Public Class AisleLocation
    <DataMember()>
    Public Property Aisle As Char

    <DataMember()>
    Public Property Shelf As Byte
End Class

Public Class ExampleClass
    Public Function DeserializeBookRecord(bytes As Byte()) As BookRecord
        Dim serializer As NetDataContractSerializer = New NetDataContractSerializer()
        Using ms As MemoryStream = New MemoryStream(bytes)
            Return CType(serializer.Deserialize(ms), BookRecord)    ' CA2311 violation
        End Using
    End Function
End Class
```

### <a name="solution"></a>Lösung

```csharp
using System;
using System.IO;
using System.Runtime.Serialization;

public class BookRecordSerializationBinder : SerializationBinder
{
    public override Type BindToType(string assemblyName, string typeName)
    {
        // One way to discover expected types is through testing deserialization
        // of **valid** data and logging the types used.

        ////Console.WriteLine($"BindToType('{assemblyName}', '{typeName}')");

        if (typeName == "BookRecord" || typeName == "AisleLocation")
        {
            return null;
        }
        else
        {
            throw new ArgumentException("Unexpected type", nameof(typeName));
        }
    }
}

[DataContract]
public class BookRecord
{
    [DataMember]
    public string Title { get; set; }

    [DataMember]
    public AisleLocation Location { get; set; }
}

[DataContract]
public class AisleLocation
{
    [DataMember]
    public char Aisle { get; set; }

    [DataMember]
    public byte Shelf { get; set; }
}

public class ExampleClass
{
    public BookRecord DeserializeBookRecord(byte[] bytes)
    {
        NetDataContractSerializer serializer = new NetDataContractSerializer();
        serializer.Binder = new BookRecordSerializationBinder();
        using (MemoryStream ms = new MemoryStream(bytes))
        {
            return (BookRecord) serializer.Deserialize(ms);
        }
    }
}
```

```vb
Imports System
Imports System.IO
Imports System.Runtime.Serialization

Public Class BookRecordSerializationBinder
    Inherits SerializationBinder

    Public Overrides Function BindToType(assemblyName As String, typeName As String) As Type
        ' One way to discover expected types is through testing deserialization
        ' of **valid** data and logging the types used.

        'Console.WriteLine($"BindToType('{assemblyName}', '{typeName}')")

        If typeName = "BinaryFormatterVB.BookRecord" Or typeName = "BinaryFormatterVB.AisleLocation" Then
            Return Nothing
        Else
            Throw New ArgumentException("Unexpected type", NameOf(typeName))
        End If
    End Function
End Class

<DataContract()>
Public Class BookRecord
    <DataMember()>
    Public Property Title As String

    <DataMember()>
    Public Property Location As AisleLocation
End Class

<DataContract()>
Public Class AisleLocation
    <DataMember()>
    Public Property Aisle As Char

    <DataMember()>
    Public Property Shelf As Byte
End Class

Public Class ExampleClass
    Public Function DeserializeBookRecord(bytes As Byte()) As BookRecord
        Dim serializer As NetDataContractSerializer = New NetDataContractSerializer()
        serializer.Binder = New BookRecordSerializationBinder()
        Using ms As MemoryStream = New MemoryStream(bytes)
            Return CType(serializer.Deserialize(ms), BookRecord)
        End Using
    End Function
End Class
```

## <a name="related-rules"></a>Verwandte Regeln

[CA2310: Verwenden Sie nicht den unsicheren Deserialisierer NetDataContractSerializer.](ca2310.md)

[CA2312: Stellen Sie sicher, dass NetDataContractSerializer. Binder vor der Deserialisierung festgelegt ist.](ca2312.md)
